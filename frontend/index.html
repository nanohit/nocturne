<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>alphy</title>

    <!-- Video.js -->
    <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet">
    <!-- IBM Plex Mono for logo -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@700&display=swap" rel="stylesheet">

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #222;
        }

        .logo {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            color: #e50914;
            cursor: pointer;
            text-decoration: none;
            position: relative;
            display: inline-block;
            padding-bottom: 14px;
        }

        .logo .beta {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 10px;
            color: #888;
            font-weight: normal;
            position: absolute;
            bottom: 0;
            left: 0;
        }

        .search-box {
            flex: 1;
            display: flex;
            gap: 10px;
        }

        .search-box input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 4px;
            background: #222;
            color: #fff;
            font-size: 16px;
        }

        .search-box input:focus {
            outline: 2px solid #e50914;
        }

        .search-box button {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            background: #e50914;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
        }

        .search-box button:hover {
            background: #f40612;
        }

        /* Continue Watching Section */
        .continue-section {
            display: none;
            margin-bottom: 30px;
        }

        .continue-section.active {
            display: block;
        }

        .continue-section h3 {
            font-size: 16px;
            color: #ccc;
            margin-bottom: 15px;
        }

        .continue-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }

        .continue-card {
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .continue-card:hover {
            transform: scale(1.05);
        }

        .continue-dismiss {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: none;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            line-height: 1;
        }

        .continue-dismiss:hover {
            background: rgba(229,9,20,0.8);
        }

        .continue-poster {
            width: 100%;
            aspect-ratio: 2/3;
            background: #333;
            object-fit: cover;
        }

        .continue-info {
            padding: 10px 12px 12px;
        }

        .continue-title {
            font-size: 13px;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .continue-meta {
            font-size: 11px;
            color: #e50914;
            margin-bottom: 6px;
        }

        .continue-progress {
            width: 100%;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .continue-progress-bar {
            height: 100%;
            background: #e50914;
            border-radius: 2px;
        }

        /* Player Section */
        .player-section {
            display: none;
            margin-bottom: 30px;
        }

        .player-section.active {
            display: block;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .player-title {
            font-size: 20px;
        }

        .player-controls {
            display: flex;
            gap: 10px;
        }

        .player-controls select {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #222;
            color: #fff;
            font-size: 14px;
        }

        .back-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #333;
            color: #fff;
            cursor: pointer;
        }

        .video-container {
            width: 100%;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }

        .video-js {
            width: 100%;
            background: #000;
        }

        /* Remove blue focus outline from player */
        .video-js:focus,
        .video-js *:focus,
        .video-container *:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        /* Results Section */
        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }

        .result-card {
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .result-card:hover {
            transform: scale(1.05);
        }

        .result-poster {
            width: 100%;
            aspect-ratio: 2/3;
            background: #333;
            object-fit: cover;
        }

        .result-info {
            padding: 12px;
        }

        .result-title {
            font-size: 14px;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .result-meta {
            font-size: 12px;
            color: #888;
        }

        /* Episode Selector */
        .episode-section {
            display: none;
            margin-bottom: 30px;
        }

        .episode-section.active {
            display: block;
        }

        .season-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .season-tab {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #222;
            color: #fff;
            cursor: pointer;
            white-space: nowrap;
        }

        .season-tab.active {
            background: #e50914;
        }

        .episodes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
        }

        .episode-btn {
            padding: 12px;
            border: none;
            border-radius: 4px;
            background: #222;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
        }

        .episode-btn:hover {
            background: #333;
        }

        .episode-btn.active {
            background: #e50914;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #e50914;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #e50914;
            padding: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo" onclick="goHome()">alphy<span class="beta">beta</span></div>
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search movies and TV shows...">
                <button onclick="search()">Search</button>
            </div>
        </header>

        <!-- Continue Watching Section (homepage) -->
        <div id="continueSection" class="continue-section">
            <h3 id="continueHeader">Continue watching</h3>
            <div id="continueGrid" class="continue-grid"></div>
        </div>

        <!-- Player Section -->
        <div id="playerSection" class="player-section">
            <div class="player-header">
                <h2 id="playerTitle" class="player-title"></h2>
                <div class="player-controls">
                    <select id="translationSelect" onchange="changeTranslation()"></select>
                    <select id="qualitySelect" onchange="changeQuality()">
                        <option value="">Auto</option>
                    </select>
                    <select id="speedSelect" onchange="changeSpeed()">
                        <option value="0.25">0.25x</option>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="1.75">1.75x</option>
                        <option value="2">2x</option>
                    </select>
                    <button class="back-btn" onclick="hidePlayer()">Back</button>
                </div>
            </div>
            <div class="video-container">
                <video id="videoPlayer" class="video-js vjs-big-play-centered" controls preload="auto">
                </video>
            </div>
        </div>

        <!-- Episode Selector (for series) -->
        <div id="episodeSection" class="episode-section">
            <div id="seasonTabs" class="season-tabs"></div>
            <div id="episodesGrid" class="episodes-grid"></div>
        </div>

        <!-- Search Results -->
        <div id="resultsSection" class="results-section">
            <div id="resultsGrid" class="results-grid"></div>
        </div>

        <div id="loading" class="loading" style="display: none;">
            <div class="spinner"></div>
            <div>Loading...</div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
    </div>

    <!-- Video.js -->
    <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>

    <script>
        const API_BASE = '/api';
        let player = null;
        let currentContent = null;
        let currentSeason = 1;
        let currentEpisode = 1;
        let currentTranslation = null;
        let currentAllUrls = {};
        let currentSpeed = 1;
        let lastSubtitleIndex = 0;
        let progressInterval = null;

        // =====================
        // localStorage Watch History
        // =====================
        function getWatchHistory() {
            try {
                return JSON.parse(localStorage.getItem('alphy_watch') || '[]');
            } catch { return []; }
        }

        function saveWatchHistory(history) {
            localStorage.setItem('alphy_watch', JSON.stringify(history));
        }

        function updateWatchProgress(contentUrl, data) {
            let history = getWatchHistory();
            const idx = history.findIndex(h => h.url === contentUrl &&
                h.season === (data.season || null) &&
                h.episode === (data.episode || null));
            const entry = {
                url: contentUrl,
                title: data.title,
                poster: data.poster || null,
                type: data.type,
                season: data.season || null,
                episode: data.episode || null,
                currentTime: data.currentTime,
                duration: data.duration,
                progress: data.duration > 0 ? data.currentTime / data.duration : 0,
                timestamp: Date.now(),
                // for series: info needed to compute next episode
                nextSeason: data.nextSeason || null,
                nextEpisode: data.nextEpisode || null,
                finished: data.progress >= 0.9
            };
            if (idx >= 0) {
                history[idx] = entry;
            } else {
                history.unshift(entry);
            }
            // Keep only 5 most recent, sorted by timestamp
            history.sort((a, b) => b.timestamp - a.timestamp);
            history = history.slice(0, 5);
            saveWatchHistory(history);
        }

        function removeFromHistory(contentUrl, season, episode) {
            let history = getWatchHistory();
            history = history.filter(h => !(h.url === contentUrl &&
                h.season === (season || null) &&
                h.episode === (episode || null)));
            saveWatchHistory(history);
            renderContinueWatching();
        }

        function getNextEpisodeInfo() {
            if (!currentContent?.info?.is_series) return { nextSeason: null, nextEpisode: null };
            const seasons = currentContent.info.seasons;
            const seasonKeys = Object.keys(seasons).map(Number).sort((a, b) => a - b);
            const currentEps = seasons[currentSeason] || [];
            const epIdx = currentEps.indexOf(currentEpisode);
            if (epIdx < currentEps.length - 1) {
                return { nextSeason: currentSeason, nextEpisode: currentEps[epIdx + 1] };
            }
            // Try next season
            const sIdx = seasonKeys.indexOf(currentSeason);
            if (sIdx < seasonKeys.length - 1) {
                const nextS = seasonKeys[sIdx + 1];
                const nextEps = seasons[nextS] || [];
                if (nextEps.length > 0) {
                    return { nextSeason: nextS, nextEpisode: nextEps[0] };
                }
            }
            return { nextSeason: null, nextEpisode: null };
        }

        function startProgressTracking() {
            stopProgressTracking();
            progressInterval = setInterval(() => {
                if (!player || !currentContent) return;
                const dur = player.duration();
                const cur = player.currentTime();
                if (!dur || dur <= 0) return;

                const { nextSeason, nextEpisode } = getNextEpisodeInfo();
                const progress = cur / dur;

                updateWatchProgress(currentContent.url, {
                    title: currentContent.title,
                    poster: currentContent.poster,
                    type: currentContent.info?.is_series ? 'series' : 'movie',
                    season: currentContent.info?.is_series ? currentSeason : null,
                    episode: currentContent.info?.is_series ? currentEpisode : null,
                    currentTime: cur,
                    duration: dur,
                    progress: progress,
                    nextSeason,
                    nextEpisode
                });
            }, 5000); // save every 5 seconds
        }

        function stopProgressTracking() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }

        function renderContinueWatching() {
            const history = getWatchHistory();
            const section = document.getElementById('continueSection');
            const grid = document.getElementById('continueGrid');
            const header = document.getElementById('continueHeader');

            // Filter: only show entries that are not fully watched (< 90%) OR finished series with next ep
            const items = history.filter(h => {
                if (h.type === 'series' && h.finished && h.nextEpisode !== null) return true;
                if (!h.finished) return true;
                return false;
            });

            if (items.length === 0) {
                section.classList.remove('active');
                return;
            }

            grid.innerHTML = '';
            items.forEach(item => {
                const card = document.createElement('div');
                card.className = 'continue-card';

                const isNextEp = item.type === 'series' && item.finished && item.nextEpisode !== null;
                let metaText = '';
                if (isNextEp) {
                    metaText = `Next: S${item.nextSeason}E${item.nextEpisode}`;
                } else if (item.type === 'series') {
                    metaText = `S${item.season}E${item.episode}`;
                } else {
                    const mins = Math.floor((item.duration - item.currentTime) / 60);
                    metaText = `${mins} min left`;
                }

                card.innerHTML = `
                    <button class="continue-dismiss" onclick="event.stopPropagation(); removeFromHistory('${item.url}', ${item.season}, ${item.episode})">&times;</button>
                    <img class="continue-poster" src="${item.poster || 'https://via.placeholder.com/200x300?text=No+Image'}" alt="">
                    <div class="continue-info">
                        <div class="continue-title">${item.title}</div>
                        <div class="continue-meta">${metaText}</div>
                        <div class="continue-progress"><div class="continue-progress-bar" style="width: ${isNextEp ? 0 : Math.round(item.progress * 100)}%"></div></div>
                    </div>
                `;

                card.onclick = () => {
                    if (isNextEp) {
                        resumeContent(item.url, item.title, item.poster, item.nextSeason, item.nextEpisode, 0);
                    } else {
                        resumeContent(item.url, item.title, item.poster, item.season, item.episode, item.currentTime);
                    }
                };

                grid.appendChild(card);
            });

            // Set header text
            const hasNextEp = items.some(i => i.type === 'series' && i.finished && i.nextEpisode !== null);
            const hasContinue = items.some(i => !i.finished);
            if (hasNextEp && !hasContinue) {
                header.textContent = 'Next episode';
            } else {
                header.textContent = 'Continue watching';
            }

            section.classList.add('active');
        }

        async function resumeContent(url, title, poster, season, episode, resumeTime) {
            showLoading();
            currentContent = { url, title, poster };

            try {
                const response = await fetch(`${API_BASE}/content?url=${encodeURIComponent(url)}`);
                const data = await response.json();
                currentContent.info = data;

                // Setup translation selector
                const transSelect = document.getElementById('translationSelect');
                transSelect.innerHTML = data.translations.map(t =>
                    `<option value="${t.id}">${t.name}</option>`
                ).join('');

                let defaultTrans = null;
                for (let i = data.translations.length - 1; i >= 0; i--) {
                    const name = data.translations[i].name.toLowerCase();
                    if (name.includes('оригинал') || name.includes('субтитры')) {
                        defaultTrans = data.translations[i];
                        break;
                    }
                }
                if (defaultTrans) {
                    currentTranslation = defaultTrans.id;
                    transSelect.value = defaultTrans.id;
                } else {
                    currentTranslation = data.translations[0]?.id;
                }

                if (data.is_series) {
                    const seasons = Object.keys(data.seasons).map(Number).sort((a, b) => a - b);
                    const tabsEl = document.getElementById('seasonTabs');
                    tabsEl.innerHTML = seasons.map(s =>
                        `<button class="season-tab ${s === season ? 'active' : ''}" onclick="selectSeason(${s})">Season ${s}</button>`
                    ).join('');
                    selectSeason(season);
                    document.getElementById('episodeSection').classList.add('active');
                    document.getElementById('resultsSection').classList.remove('active');
                    document.getElementById('continueSection').classList.remove('active');

                    currentSeason = season;
                    currentEpisode = episode;
                    playStream(url, season, episode, resumeTime);
                    // highlight episode
                    document.querySelectorAll('.episode-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.textContent === `Ep ${episode}`);
                    });
                } else {
                    document.getElementById('continueSection').classList.remove('active');
                    playStream(url, null, null, resumeTime);
                }
            } catch (e) {
                showError('Failed to resume: ' + e.message);
            }
        }

        // =====================
        // Player
        // =====================
        function initPlayer() {
            if (player) return;
            player = videojs('videoPlayer', {
                fluid: false,
                html5: {
                    vhs: {
                        overrideNative: true
                    },
                    nativeAudioTracks: false,
                    nativeVideoTracks: false
                }
            });

            player.on('loadedmetadata', () => {
                const vw = player.videoWidth();
                const vh = player.videoHeight();
                if (vw && vh) {
                    const container = document.querySelector('.video-container');
                    const width = container.clientWidth;
                    const height = Math.round(width * (vh / vw));
                    player.dimensions(width, height);
                }
            });

            window.addEventListener('resize', () => {
                if (!player || player.isFullscreen()) return;
                const vw = player.videoWidth();
                const vh = player.videoHeight();
                if (vw && vh) {
                    const container = document.querySelector('.video-container');
                    const width = container.clientWidth;
                    const height = Math.round(width * (vh / vw));
                    player.dimensions(width, height);
                }
            });

            // When episode finishes, check for next episode
            player.on('ended', () => {
                if (currentContent?.info?.is_series) {
                    const { nextSeason, nextEpisode } = getNextEpisodeInfo();
                    if (nextEpisode !== null) {
                        // Save finished state
                        updateWatchProgress(currentContent.url, {
                            title: currentContent.title,
                            poster: currentContent.poster,
                            type: 'series',
                            season: currentSeason,
                            episode: currentEpisode,
                            currentTime: player.duration(),
                            duration: player.duration(),
                            progress: 1,
                            nextSeason,
                            nextEpisode
                        });
                    }
                }
            });
        }

        // Search
        async function search() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;

            showLoading();
            hidePlayer();

            try {
                const response = await fetch(`${API_BASE}/search?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                displayResults(data.results);
            } catch (e) {
                showError('Search failed: ' + e.message);
            }
        }

        function displayResults(results) {
            hideLoading();
            const grid = document.getElementById('resultsGrid');
            grid.innerHTML = '';

            if (!results.length) {
                grid.innerHTML = '<p style="color:#888">No results found</p>';
            }

            results.forEach(item => {
                const card = document.createElement('div');
                card.className = 'result-card';
                card.onclick = () => selectContent(item);
                card.innerHTML = `
                    <img class="result-poster" src="${item.poster || 'https://via.placeholder.com/200x300?text=No+Image'}" alt="">
                    <div class="result-info">
                        <div class="result-title">${item.title}</div>
                        <div class="result-meta">${item.type} ${item.year || ''}</div>
                    </div>
                `;
                grid.appendChild(card);
            });

            document.getElementById('resultsSection').classList.add('active');
            document.getElementById('continueSection').classList.remove('active');
        }

        async function selectContent(item) {
            showLoading();
            currentContent = item;

            try {
                const response = await fetch(`${API_BASE}/content?url=${encodeURIComponent(item.url)}`);
                const data = await response.json();

                currentContent.info = data;

                const transSelect = document.getElementById('translationSelect');
                transSelect.innerHTML = data.translations.map(t =>
                    `<option value="${t.id}">${t.name}</option>`
                ).join('');

                let defaultTrans = null;
                for (let i = data.translations.length - 1; i >= 0; i--) {
                    const name = data.translations[i].name.toLowerCase();
                    if (name.includes('оригинал') || name.includes('субтитры')) {
                        defaultTrans = data.translations[i];
                        break;
                    }
                }
                if (defaultTrans) {
                    currentTranslation = defaultTrans.id;
                    transSelect.value = defaultTrans.id;
                } else {
                    currentTranslation = data.translations[0]?.id;
                }

                if (data.is_series) {
                    setupEpisodeSelector(data);
                } else {
                    playStream(item.url);
                }
            } catch (e) {
                showError('Failed to load content: ' + e.message);
            }
        }

        function setupEpisodeSelector(info) {
            hideLoading();
            const seasons = Object.keys(info.seasons).map(Number).sort((a, b) => a - b);
            const firstSeason = seasons[0] || 1;

            const tabsEl = document.getElementById('seasonTabs');
            tabsEl.innerHTML = seasons.map(s =>
                `<button class="season-tab ${s === firstSeason ? 'active' : ''}" onclick="selectSeason(${s})">Season ${s}</button>`
            ).join('');

            selectSeason(firstSeason);

            document.getElementById('episodeSection').classList.add('active');
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('continueSection').classList.remove('active');

            // Load first episode but don't autoplay
            const firstEpisodes = info.seasons[firstSeason] || [];
            if (firstEpisodes.length > 0) {
                currentSeason = firstSeason;
                currentEpisode = firstEpisodes[0];
                playStream(currentContent.url, firstSeason, firstEpisodes[0]);
                document.querySelectorAll('.episode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.textContent === `Ep ${firstEpisodes[0]}`);
                });
            }
        }

        function selectSeason(season) {
            currentSeason = season;
            const episodes = currentContent.info.seasons[season] || [];

            document.querySelectorAll('.season-tab').forEach(tab => {
                tab.classList.toggle('active', tab.textContent.includes(season));
            });

            const grid = document.getElementById('episodesGrid');
            grid.innerHTML = episodes.map(ep =>
                `<button class="episode-btn" onclick="playEpisode(${season}, ${ep})">Ep ${ep}</button>`
            ).join('');
        }

        function playEpisode(season, episode) {
            currentSeason = season;
            currentEpisode = episode;
            playStream(currentContent.url, season, episode);

            document.querySelectorAll('.episode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent === `Ep ${episode}`);
            });
        }

        async function playStream(url, season = null, episode = null, resumeTime = 0) {
            showLoading();
            initPlayer();
            stopProgressTracking();

            try {
                let apiUrl = `${API_BASE}/stream?url=${encodeURIComponent(url)}`;
                if (season !== null) apiUrl += `&season=${season}`;
                if (episode !== null) apiUrl += `&episode=${episode}`;
                if (currentTranslation) apiUrl += `&translator_id=${currentTranslation}`;

                const response = await fetch(apiUrl);
                const data = await response.json();

                if (!data.stream_url) {
                    throw new Error('No stream URL returned');
                }

                currentAllUrls = data.all_urls || {};

                const qualitySelect = document.getElementById('qualitySelect');
                qualitySelect.innerHTML = '';
                const qualities = Object.keys(currentAllUrls);
                if (qualities.length > 0) {
                    qualities.forEach(q => {
                        const opt = document.createElement('option');
                        opt.value = q;
                        opt.textContent = q;
                        qualitySelect.appendChild(opt);
                    });
                    qualitySelect.value = qualities[qualities.length - 1];
                } else {
                    qualitySelect.innerHTML = '<option value="">Auto</option>';
                }

                const streamUrl = qualities.length > 0
                    ? currentAllUrls[qualities[qualities.length - 1]]
                    : data.stream_url;
                player.src({
                    src: streamUrl,
                    type: streamUrl.includes('.m3u8') ? 'application/x-mpegURL' : 'video/mp4'
                });

                // Remove old text tracks
                const oldTracks = player.remoteTextTracks();
                for (let i = oldTracks.length - 1; i >= 0; i--) {
                    player.removeRemoteTextTrack(oldTracks[i]);
                }

                if (data.subtitles) {
                    data.subtitles.forEach((sub, i) => {
                        player.addRemoteTextTrack({
                            kind: 'subtitles',
                            label: sub.name || sub.lang,
                            srclang: sub.lang,
                            src: sub.url,
                            default: i === 0
                        }, false);
                    });
                }

                player.playbackRate(currentSpeed);

                // Resume from saved position if provided
                if (resumeTime > 0) {
                    player.one('loadedmetadata', () => {
                        player.currentTime(resumeTime);
                    });
                }

                // Do NOT autoplay — user clicks play manually

                // Show player
                const displayTitle = currentContent.title + (season ? ` - S${season}E${episode}` : '');
                document.getElementById('playerTitle').textContent = displayTitle;
                document.title = displayTitle;
                document.getElementById('playerSection').classList.add('active');
                document.getElementById('resultsSection').classList.remove('active');

                // Start tracking progress
                startProgressTracking();

                hideLoading();
            } catch (e) {
                showError('Failed to load stream: ' + e.message);
            }
        }

        function changeTranslation() {
            currentTranslation = document.getElementById('translationSelect').value;
            if (currentContent.info?.is_series) {
                playEpisode(currentSeason, currentEpisode);
            } else {
                playStream(currentContent.url);
            }
        }

        function hidePlayer() {
            document.getElementById('playerSection').classList.remove('active');
            document.getElementById('episodeSection').classList.remove('active');
            document.getElementById('resultsSection').classList.add('active');
            if (player) player.pause();
            stopProgressTracking();
            document.title = 'alphy';
        }

        function goHome() {
            hidePlayer();
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('searchInput').value = '';
            document.getElementById('resultsGrid').innerHTML = '';
            document.title = 'alphy';
            renderContinueWatching();
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function showError(msg) {
            hideLoading();
            document.getElementById('error').textContent = msg;
            document.getElementById('error').style.display = 'block';
        }

        function changeQuality() {
            const quality = document.getElementById('qualitySelect').value;
            if (!quality || !currentAllUrls[quality]) return;

            const currentTime = player.currentTime();
            const wasPaused = player.paused();
            const url = currentAllUrls[quality];

            player.src({
                src: url,
                type: url.includes('.m3u8') ? 'application/x-mpegURL' : 'video/mp4'
            });

            player.one('loadedmetadata', () => {
                player.currentTime(currentTime);
                player.playbackRate(currentSpeed);
                if (!wasPaused) player.play();
            });
        }

        function changeSpeed() {
            currentSpeed = parseFloat(document.getElementById('speedSelect').value);
            if (player) player.playbackRate(currentSpeed);
        }

        // Keyboard shortcuts — use e.code for layout independence
        document.addEventListener('keydown', e => {
            if (document.activeElement === document.getElementById('searchInput')) return;
            if (!document.getElementById('playerSection').classList.contains('active')) return;
            if (!player) return;

            const code = e.code;

            // Arrow keys work regardless of layout
            if (code === 'ArrowRight') {
                e.preventDefault();
                player.currentTime(player.currentTime() + 10);
                return;
            }
            if (code === 'ArrowLeft') {
                e.preventDefault();
                player.currentTime(player.currentTime() - 10);
                return;
            }
            if (code === 'ArrowUp') {
                e.preventDefault();
                player.volume(Math.min(1, player.volume() + 0.05));
                return;
            }
            if (code === 'ArrowDown') {
                e.preventDefault();
                player.volume(Math.max(0, player.volume() - 0.05));
                return;
            }
            if (code === 'Space' || code === 'KeyK') {
                e.preventDefault();
                if (player.paused()) player.play(); else player.pause();
                return;
            }
            if (code === 'KeyF') {
                e.preventDefault();
                if (player.isFullscreen()) player.exitFullscreen(); else player.requestFullscreen();
                return;
            }
            if (code === 'KeyC') {
                e.preventDefault();
                const tracks = player.textTracks();
                let activeTrackIdx = -1;
                for (let i = 0; i < tracks.length; i++) {
                    if ((tracks[i].kind === 'subtitles' || tracks[i].kind === 'captions') && tracks[i].mode === 'showing') {
                        activeTrackIdx = i;
                        break;
                    }
                }
                if (activeTrackIdx >= 0) {
                    lastSubtitleIndex = activeTrackIdx;
                    for (let i = 0; i < tracks.length; i++) {
                        if (tracks[i].kind === 'subtitles' || tracks[i].kind === 'captions') {
                            tracks[i].mode = 'disabled';
                        }
                    }
                } else {
                    for (let i = 0; i < tracks.length; i++) {
                        if (tracks[i].kind === 'subtitles' || tracks[i].kind === 'captions') {
                            tracks[i].mode = (i === lastSubtitleIndex) ? 'showing' : 'disabled';
                        }
                    }
                }
                return;
            }
            // Shift+. (>) and Shift+, (<) for speed — use Period/Comma codes
            if (e.shiftKey && (code === 'Period' || code === 'Comma')) {
                e.preventDefault();
                const speeds = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
                const idx = speeds.indexOf(currentSpeed);
                if (code === 'Period' && idx < speeds.length - 1) {
                    currentSpeed = speeds[idx + 1];
                } else if (code === 'Comma' && idx > 0) {
                    currentSpeed = speeds[idx - 1];
                }
                player.playbackRate(currentSpeed);
                document.getElementById('speedSelect').value = currentSpeed;
                return;
            }
        });

        // Enter key to search
        document.getElementById('searchInput').addEventListener('keypress', e => {
            if (e.key === 'Enter') search();
        });

        // Show continue watching on page load
        renderContinueWatching();
    </script>
</body>
</html>
